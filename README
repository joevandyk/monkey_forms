Monkey Forms Overview

# TODO Rewrite this so that it makes sense.


NOTE!  You need to use this version of deep_merge for now!
https://github.com/joevandyk/deep_merge


MonkeyForms::Form is an interface / layer between ActionController
and your Models (or whatever you are saving the data to).
You could just send an email after they submit the form.
Your views also access the form object.

After you submit the form, the values you submit are serialized
into a gzip'd encoded cookie with json in it.
This allows us to access the stuff you entered earlier.

How forms are serialized is configurable, by the way.  See 
lib/monkey_forms/gzip_cookie.rb.

When you submit the next form (or the same form again),
the values you submit are merged into the already-submitted
form values that are saved in the cookie.  So, you could submit
an ajax request that only has one form attribute, and it would
merge that one attribute with the other stuff you already submitted
earlier.

We use the standard ActiveModel::Validator stuff.  The
validation_scopes allows us to scope validations, so
we'd only run the validations for certain attributes.

The /test directory contains a sample Sinatra application that
has a sample form.

ActiveModel should be the only dependency.

This is pretty similar to the Presenter Pattern as described
by Jay Fields, by the way. http://blog.jayfields.com/2007/03/rails-presenter-pattern.html

There is a sample sinatra application in test/sinatra.  Run with:
cd test/sinatra
rackup config.ru

The validation stuff still needs work, but the form serializing seems to be
solid.


CODE SAMPLES
class OrderForm
  include MonkeyForms::Form
  form_attributes :name, :address, :city, :state, :zip 
  
  # This might be set by default -- maybe the the below line wouldn't be needed
  set_form_storage MonkeyForms::GzipCookie.new(:name => 'order_cookie')
  
  validates :name, :presence => true

  def save
    address = Address.new(:street => address, :city => city, :state => state, :zip => zip)
    OrderService.place_order(:the_name => name, :address => address)
    reset # clears out saved cookie
  end
end

class OrderController < ActionController::Base
  before_filter :load_form
  def page1
  end

  def page2
  end

  def page3
    if @form.valid?
      @form.save
      redirect 'somewhere'
    end
  end

  private
 
  def load_form
    @form = OrderForm.new(:request => request, :response => self)
  end
end

Your views can access @form.name, @form.address, etc.  It will be automatically saved as you
go from page to page.  @form behaves just like a standard ActiveRecord / ActiveModel object.

Validation isn't shown in this example -- how validation works is still TBD.


??? WHY ???

Moving the form logic to a separate class has a ton of advantages:

* Keeps the controller really simple.  

* Makes it easier to test. You can write tests directly against the form handling class.

* Classes should do one thing.

* You can have complex validations.

* Your ActiveRecord models can probably become simpler.

* Since the form handling logic is encapsulated into one class, you can use 
  inheritance, modules, etc.

* You want to move away from ActiveRecord? It's no problem -- just change how the 
  form values are saved in the #save method.
